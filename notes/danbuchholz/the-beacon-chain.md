# The Beacon Chain

A review of the Beacon Chain & a brief on related projects.

## Overview

### Proof-of-Stake & the Beacon Chain

While the existing Ethereum PoW consensus relies on trusting the canonical chain with the most hashpower (difficulty), the Beacon Chain transitions to a PoS consensus model that relies on _virtual_ mining in the form of validators + cryptographic signatures instead of hashpower. Thus, the chain with the most stake is equivalent to a PoW chain with the most hashpower. Consensus is comprised of a validator model that signs blocks to be included in the chain — slots last 12 seconds long where a block has a _chance_ to be included (missed block proposals could be due to the block-proposing validator being offline or out of sync), epochs are 32 total slots (~6.4 minutes), and "eeks" ("ethereum week," used for various longer-term operations) are 2048 epochs (~9.1 days). An important note is that missing a block proposal increases the total number of attestations that are eligible for inclusion in the next block, which is a network inefficiency since it can further delay attestation inclusion for subsequent blocks, becoming "less attractive" as exclusion continues (i.e., due to [inclusion distance](https://www.attestant.io/posts/defining-attestation-effectiveness/)). A _block_ _proposer_ is a validator that has been psuedorandomly (on-chain, so not truly random) selected to build a block for a specific slot via a [RANDAO](https://github.com/randao/randao) function where weighing is based on the validator's balance. RANDAO generates the validator set 4 epochs in advance via a "random" seed, where there is a hash from the block proposer that is continually mixed (XOR'd) into the seed (hence, the pseudorandomness). Generally, a given validator will be part of the larger pool, acting as _attesters_ that vote on blocks for the Beacon Chain (and weighted by the validator's balance). Note that a validator must be running a Beacon Chain node and is executed through one or more validator clients — to use the validator client, there must be 32 ETH staked for each client (i.e., users stake ETH to "activate" validators). To summarize, beacon nodes maintain the state of the beacon chain, manage validators, apply rewards & penalties, maintain randomness, and determine the canonical chain with finality; validators propose beacon chain blocks and vote for blocks by making attestations.

### Consensus & Finality (with a Hint of Sharding)

Currently, there are [~250k validators](https://beaconcha.in/charts/validators) for the Beacon Chain (Oct. 2021), and consensus is driven by a subset of validators that attest (sign) blocks. In practice, this uses "committees" of a minimum of 128 validators (e.g., 1 proposing, and 127 attesting each block) and maximum 2048 (due to 32 slots \* 64 max committees per slot). That is, there can be more than 1 committee per block, and a validator will only be assigned to 1 committee within 1 slot. Attestations are grouped by committee (index) where each committee can have more than 1 attestation, assuming that each validator only votes once, and there is a minimum, maximum of 64, 128 (respectively) attestations required. Attestation aggregation by specific validators allows these votes to be summarized. Once the epoch has concluded, the validators are mixed & merged into new committees. When attesting to a Beacon Chain header, validators will follow the [Gasper consensus protocol](https://blog.ethereum.org/2020/02/12/validated-staking-on-eth2-2-two-ghosts-in-a-trench-coat/) — this combines Casper, for finality (aka deciding which blocks are/aren't part of the chain), and LMD GHOST (Last Message Driven Greediest Heaviest Observed SubTree), for fork choice voting (aka adding new blocks & deciding head). Note that from a security perspective, the PoW 51% attack exists in PoS; however, it not only would be very unlikely for a malicious party to control 51% of staked ETH but also economically detrimental to act maliciously with that much invested. Relatedly, consensus assumes _at least_ 2/3 of the validator committee's **_total balance_** is honest — it's [1 in a trillion probability](https://medium.com/@chihchengliang/minimum-committee-size-explained-67047111fa20) for malicious, byzantine validators being equal to or greater than 1/3 of the committee (aka PBFT).

While sharding is a WIP and subject to (minor) change, its implementation relates to the Beacon Chain. There are 64 total shards planned to be implemented (which requires at least ~262k validators), and there will be 1 Beacon Chain block with up to 64 shard blocks proposed for each slot. Note that the "old" PoW chain will exist as its own shard. In order to keep track of the shards and enable cross-shard interoperability, the Beacon Chain will contain "crosslinks" to the head of the shard chains, which are managed by committees during block-by-block changes. For example, a group of 512 validators would be subdivided into 4 committees of 128 validators for 1 slot — all 512 cast a Beacon Chain header vote for their slot using LMD GHOST (for head aka latest block's slot/hash), and then each committee is assigned a different shard to cross-link. If there is only 1 shard that proposes a block, then there will only be 1 crosslink included in the beacon block during that slot; if all 64 have a block prop, then there will be 64 crosslinks. Thus far, this process can be compared to voting for a local government election since each slot _but not the entire epoch_ is voted on by each committee of validators.

Epoch voting — a simile to voting for a national election — allows all of the validators to cast a vote on the entire epoch at specific "checkpoints" (or "epoch boundary blocks"), which are blocks in the first slot of an epoch or, if there is not a block in the first slot, the _most recent preceding_ block (e.g., possible for 1 block to be a checkpoint for more than 1 epoch). During the LMD GHOST vote, the validator includes a _target_ vote for the checkpoint in its current epoch — this is the Casper FFG vote, which also includes the previous checkpoint, called _source_. Recall, finality occurs once a _supermajority_ of at least 2/3 **_of the total effective balance of all active validators_** is reached. Once an epoch ends, the supermajority checkpoint in the current epoch gets _justified_ but is not _finalized_ until the checkpoint in the following epoch becomes justified. That is, a checkpoint will take 2 epochs to be finalized (~12.8 minutes). Note that a transaction will, on average, be in a block that is halfway through an epoch; thus, it will not reach finality until the current epoch ends plus the 2 checkpoints requirement (i.e., 2.5 epochs total, ~16 minutes). Attestations are aggregated for each block, and finality will only occur at epoch boundaries, which causes all of the preceding blocks within that epoch to also be finalized. In terms of sharding, this means that a shard chain's block will only be finalized once it's cross-linked and included in a beacon block that's reached finality.

For the aggregation process, a group of 16 aggregators are randomly selected from each committee, who aggregate _attestations matching its own attestation_ and then forward to the block proposer. This will always occur at 2/3 of the way through an epoch (aka at 8 seconds). So, putting all of these steps together, a validator client will generate the attestation, propagate it to aggregator(s) whom perform the proper aggregation, then propagating the aggregate to the block producer, where it is finally (hopefully) included.

> **Attest (Generate > Propagate > Aggregate > Propagate > Include). Justify. Finalize.**

Once finality is reached, a number of incentives are provided. Making attestations (LMD & FFG vote) that the majority of validators agree with will result in a reward, and with sharding, it will also reward for successful cross-links. However, if a validator does not attest to a block or attests to an unfinalized block, they will be penalized. Slashing is a harsher penalization type that ranges from 3-100% (aka at least 1/32) of an entire validator's 32 ETH stake; it occurs in 3 specific scenarios: double proposal (of multiple blocks in a slot), surround vote (where a first FFG checkpoint vote is surrounded by or surrounds a second FFG vote), or double vote (2 FFG votes in same epoch, e.g., voting for checkpoint in 2 chains of a fork). Lastly, there are whistleblower incentives using proofs to show a validator should be slashed, which results in a reward of 1/512 of the penalized validator's balance. A holistic way to view these incentives is in terms of staking ROI — if you're an honest validator, you can make ~10% a year through rewards but potentially lose 7.5% through penalties...being honest and staying online 55-70% of the time will result in profitability.

In summary:

- For every epoch, validators are evenly divided across 32 slots and then subdivided into committees
- Validators in a specific slot attempt to vote on the same Beacon Chain head (LMD GHOST vote)
- Validators in a specific slot attempt attempt to finalize the same checkpoints, target & source, to eventually help finalize their epoch (Casper FFG)
- Validators in a specific slot attempt to crosslink an assigned shard for their respective committee (future-state implementation)
- Validator signatures endorse the above (hashes) where 2/3 attestations on the current epoch's checkpoint results in _justification_ and is _finalized_ upon the subsequent checkpoint being justified — i.e., 2 epochs in a row with the same checkpoint pair results in finality of the source, thus, the source epoch's blocks' finality as well
- Once finality is reached (i.e., the 2 epochs for justification/finalization), rewards / penalties are distributed

## Related Topics

### Light Clients & Sync

Light clients will provide access to the Ethereum network for devices with insufficient hardware/capacity (phones, laptops, etc.) to run a full node or unable to be constantly connected, thus, creating an inability to connect to the network directly. To enable network connectivity, light clients would be required to only keep track of the block headers — this greatly reduces the load on the device and lowers the barrier to entry. Any data not present in the block header would result in some sort of deeper query request (e.g., Merkle proof for tx or state history) to non-light-clients that have the associated data. Note that currently, Ethereum clients are heavy due to the design Ethereum's networking protocol; DevP2P includes the ETH protocol as well as gossip (blocks, txs), history (headers, blocks, receipts), and syncing state (being replaced by Snap protocol).

A light client friendly design includes smaller "sync committees" signing canonical blocks. However, with a smaller subset of nodes, this poses a security risk as they are easier to corrupt. To account for this, the overall validator committee set is very large, with random shuffling (short lookahead of ~27 hours) and frequent rotation — this makes it difficult to coordinate an attack among the sync committee subset. The committee rotations also accelerate committee syncing for light clients since the current validator committee will be validating each block in a given time period and also signing off on the next committee. This allows a light client to "skip" to a single block within each period since one block will have the signatures of the current and next committee. Once the light client is fully up-to-date, it can start syncing with each block instead of the skip sync. An interesting point is that current cross-chain trustless bridges are essentially using a light client model wherein a light client of the Beacon Chain and _X_ chain are required to interoperate.

### Portal Network & Statelessness

Portal Network, for example, aims to build a light client for low powered devices while being scalable, not requiring syncing, and maintaining usage of JSON RPC. A related concept that acts as a catalyst for light clients is statelessness. Statelessness is a change in the consensus & networking protocol that removes state from a client's requirements — if a client needs access to a specific piece of state to execute a block, it would leverage a "witness"(Merkle/Verkle proof) to retrieve that piece of data. That is, statelessness helps solve the accessibility problem for low powered devices and doesn't require fully syncing (e.g., no need to store state or chain history). However, there are still challenges when it comes to scalability and JSON RPC connections (contract interaction, tx sending, etc.) — since DevP2P expects state/chain history, a stateless client in the current Ethereum model would not abide by DevP2P requirements. This is the reason the Portal Network aims to redesign Ethereum with a new P2P network, specifically made for light clients.

# Specification Walkthrough

TO DO

---

### Sources

- [The Beacon Chain Ethereum 2.0 explainer you need to read first](https://ethos.dev/beacon-chain/)
- [Vitalik's Annoted Ethereum 2.0 Spec](https://notes.ethereum.org/@vbuterin/SkeyEI3xv)
- [Light Client Design in Eth2](https://www.youtube.com/watch?v=ysW-Bq05pJQ)
- [Stateless Ethereum and The Portal Network](https://www.youtube.com/watch?v=jAX_bgcESoc)
- [Ethereum 2.0 Knowledge Base](https://kb.beaconcha.in/glossary#beacon-chain)
- [Ethereum 2.0 Phase 0 -- The Beacon Chain](https://benjaminion.xyz/eth2-annotated-spec/phase0/beacon-chain/)
- [Combining GHOST and Casper](https://arxiv.org/pdf/2003.03052.pdf)
- [Defining Attestation Effectiveness](https://www.attestant.io/posts/defining-attestation-effectiveness/)
- [Attestation Inclusion](https://www.youtube.com/watch?v=SPcgevcDqDE)
